# Тестовое задание.

Текст задания:

> 1. На языке Python реализовать алгоритм (функцию) определения
> четности целого числа, который будет аналогичен нижеприведенному по
> функциональности, но отличен по своей сути. Объяснить плюсы и
> минусы обеих реализаций.
> 
> **Python example:** ```def isEven(value):return value%2==0```
> 
> 2. На языке Python (2.7) реализовать минимум по 2 класса
> реализовывающих циклический буфер FIFO. Объяснить плюсы и минусы
> каждой реализации.
> 
> 3. На языке Python реализовать функцию, которая быстрее всего (по
> процессорным тикам) отсортирует данный ей массив чисел. Массив
> может быть любого размера со случайным порядком чисел (в том числе
> и отсортированным). Объяснить почему вы считаете, что функция
> соответствует заданным критериям.

---

### Задача 1
Решение находится в файле 1_iseven.py, реализовано для Python третьей версии.

#### **Плюсы исходной реализации:**
- Написанный тест, замеряющий время, показал, что эта функция работает быстрее.
- Реализация более понятная, быстрая и простая.

#### **Минус новой реализации:**
- Можно было ограничится ```def new_func(value):return value & 1```, но в таком случае возвращается не True/False, a 0 или 1, поэтому потребовалось написать условную конструкцию if ... else. Проверка условия занимает время.


---

### Задача 2
Решение находится в файле 2_fifo.py, реализовано для Python второй версии.

#### **Плюс реализации RingBuffer:**
- Можно удалять элемент, добавленный раньше всех, не добавляя новый элемент.

#### **Минус реализации RingBuffer:**
- При вызове списка в пустых ячейках будет указано None

#### **Плюс реализации MagicRingBuffer:**
- На лету меняет класс с еще не заполненного буфера на полностью заполненный. При вызове списка в нем не бывает None, то есть не создаются дополнительные объекты, когда буфер еще не заполнен.

#### **Минус реализации MagicRingBuffer:**
- Нельзя удалять элемент, не добавляя новый.

#### **Плюсы обеих реализаций:**
- Последовательно записанные данные позволяют производить быструю итерацию по элементам. К тому же, при добавлении элемента не требуется снова выделять память. Каждая операция выполняется за O(1).
- Кольцевой буфер - один из самых простых и эффективных способов реализовать FIFO  без использования динамической памяти.
- Эта структура данных удобна для хранения логов или другой информации, которую можно со времением удалять, записывая на её место новую.

#### **Минус обеих реализаций:**
- Ограничение на максимальный размер. Чтобы его обойти можно реализовать очередь на связном списке.

---

### Задача 3
Решение находится в файле 3_sorting.py, реализовано для Python третьей версии.


Самой быстрой сортировкой массива, в котором числа расположены в случайном порядке (в том числе и в уже отсортированном) является Timsort. Она сочетает в себе сортировку вставками и слиянием. В лучшем случае работает за O(n), в худшем за O(n log(n)). Пространственная сложность O(1). Данная сортировка является стандартной в Python и лежит в основе встроенной функции sort().

Результаты тестов показали, что встроенная функция sort() работает быстрее реализованной сорировки Timsort. В сочетании с простотой использования sort(), эффективнее всего будет использовать именно её.

---

### Автор
Соколов Михаил
